diff --git a/node_modules/@bazel/typescript/internal/ts_project.bzl b/node_modules/@bazel/typescript/internal/ts_project.bzl
index ee340fe..a657666 100755
--- a/node_modules/@bazel/typescript/internal/ts_project.bzl
+++ b/node_modules/@bazel/typescript/internal/ts_project.bzl
@@ -665,11 +665,16 @@ def ts_project_macro(
                 Label(typescript_package),
                 Label("//@bazel/typescript"),
                 tsconfig,
+                # allow to use --worker_sandboxing option
+                Label("//@bazel/typescript/internal/worker:filegroup"),
+                "@build_bazel_rules_nodejs//internal/linker:index.js"
             ],
             entry_point = Label("//@bazel/typescript/internal/worker:index.js"),
             templated_args = [
                 "--typescript_require_path",
                 typescript_require_path,
+                "--linker_require_path",
+                "$(rlocation {})".format("build_bazel_rules_nodejs/internal/linker/index.js"),
             ],
         )
 
diff --git a/node_modules/@bazel/typescript/internal/worker/index.js b/node_modules/@bazel/typescript/internal/worker/index.js
index 08bf866..4a840cc 100755
--- a/node_modules/@bazel/typescript/internal/worker/index.js
+++ b/node_modules/@bazel/typescript/internal/worker/index.js
@@ -14,6 +14,8 @@ const ts = require("typescript");
 const MNEMONIC = 'TsProject';
 const worker = require('./worker');
 let createWatchCompilerHost;
+let relinkNodeModules;
+const filesCache = new Map();
 const formatHost = {
     getCanonicalFileName: (path) => path,
     getCurrentDirectory: ts.sys.getCurrentDirectory,
@@ -26,7 +28,15 @@ const reportWatchStatusChanged = (diagnostic) => {
     worker.debug(ts.formatDiagnostic(diagnostic, formatHost));
 };
 function createWatchProgram(options, tsconfigPath, setTimeout) {
-    const host = createWatchCompilerHost(tsconfigPath, options, Object.assign(Object.assign({}, ts.sys), { setTimeout }), ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic, reportWatchStatusChanged);
+    const host = createWatchCompilerHost(tsconfigPath, options, Object.assign(Object.assign({}, ts.sys), { setTimeout, write: worker.debug,
+        writeFile: (filename, ...args) => {
+            ts.sys.writeFile(filename, ...args);
+            // here we collect all output from Typescript into FS to the memory cache
+            // we need it to restore correct FS state between Bazel runs.
+            worker.debug('update files cache with: ', filename);
+            filesCache.set(filename, args);
+        }
+    }), ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic, reportWatchStatusChanged);
     return ts.createWatchProgram(host);
 }
 let workerRequestTimestamp;
@@ -53,10 +63,23 @@ function getWatchProgram(args) {
 function emitOnce(args) {
     return __awaiter(this, void 0, void 0, function* () {
         const watchProgram = getWatchProgram(args);
+        workerRequestTimestamp = Date.now();
         if (consolidateChangesCallback) {
+            // consolidateChangesCallback is defined only when the build triggers a "warm" worker.
+            // In "warm" state TypeScript will emit only changed files,
+            // and, since Bazel clean package output folder for each build,
+            // we need to restore the File System state to what TypeScript expects to see.
+            // To do it we do several things. At first we restore all node_modules links
+            // by triggering bazel_nodejs_linker service:
+            yield relinkNodeModules();
+            // And at second we take all files that we previously cache in the filesCache
+            // To do it we take all files that we previously cache in the filesCache
+            // and rewrite them using TS API.
+            // TODO: it may be more efficient to do the same thing by passing custom ts.CreateProgram factory in the createWatchProgram.
+            filesCache.forEach((args, filename) =>  ts.sys.writeFile(filename, ...args));
+            worker.debug('file restore finished in: ', Date.now() - workerRequestTimestamp, 'ms');
             consolidateChangesCallback();
         }
-        workerRequestTimestamp = Date.now();
         const result = yield (watchProgram === null || watchProgram === void 0 ? void 0 : watchProgram.getProgram().emit(undefined, undefined, {
             isCancellationRequested: function (timestamp) {
                 return timestamp !== workerRequestTimestamp;
@@ -80,6 +103,21 @@ function main() {
         worker.log(`typescript_require_path '${typescriptRequirePath}' could not be resolved`);
         throw e;
     }
+
+    const linkerRequirePath = process.argv[process.argv.indexOf('--linker_require_path') + 1];
+    try {
+        const linker = require(linkerRequirePath);
+        worker.log('init linker callback', linkerRequirePath)
+        relinkNodeModules = () => {
+            worker.log('invoke linker')
+            return linker.main([process.env.MODULES_MANIFEST], require(process.env['BAZEL_NODE_RUNFILES_HELPER']));
+        }
+    }
+    catch (e) {
+        worker.log(`linker_require_path '${linkerRequirePath}' could not be resolved`);
+        throw e;
+    }
+
     if (process.argv.includes('--persistent_worker')) {
         worker.log(`Running ${MNEMONIC} as a Bazel worker`);
         worker.runWorkerLoop(emitOnce);
diff --git a/node_modules/@bazel/typescript/internal/worker/worker.js b/node_modules/@bazel/typescript/internal/worker/worker.js
index d6e188a..97d1da7 100755
--- a/node_modules/@bazel/typescript/internal/worker/worker.js
+++ b/node_modules/@bazel/typescript/internal/worker/worker.js
@@ -32,7 +32,8 @@ if (typeof global.gc !== 'function') {
  * Whether to print debug messages (to console.error) from the debug function
  * below.
  */
-exports.DEBUG = false;
+// expose debug logs only for builds with --define=VERBOSE_LOGS=1
+exports.DEBUG = process.env.VERBOSE_LOGS === '1';
 /** Maybe print a debug message (depending on a flag defaulting to false). */
 function debug(...args) {
     if (exports.DEBUG)
