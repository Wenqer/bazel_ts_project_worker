diff --git a/node_modules/@bazel/typescript/internal/ts_project.bzl b/node_modules/@bazel/typescript/internal/ts_project.bzl
index ee340fe..3106276 100755
--- a/node_modules/@bazel/typescript/internal/ts_project.bzl
+++ b/node_modules/@bazel/typescript/internal/ts_project.bzl
@@ -186,11 +186,17 @@ def _ts_project_impl(ctx):
     typings_outputs = ctx.outputs.typings_outs + ctx.outputs.typing_maps_outs + [s for s in ctx.files.srcs if s.path.endswith(".d.ts")]
     default_outputs_depset = depset(runtime_outputs) if len(runtime_outputs) else depset(typings_outputs)
 
+    args = [
+        "--nobazel_run_linker",
+        "--nobazel_patch_module_resolver",
+        arguments,
+    ] if ctx.attr.supports_workers else [arguments]
+
     if len(outputs) > 0:
         run_node(
             ctx,
             inputs = inputs,
-            arguments = [arguments],
+            arguments = args,
             outputs = outputs,
             mnemonic = "TsProject",
             executable = "tsc",
@@ -665,6 +671,8 @@ def ts_project_macro(
                 Label(typescript_package),
                 Label("//@bazel/typescript"),
                 tsconfig,
+                # allow to use --worker_sandboxing option
+                Label("//@bazel/typescript/internal/worker:filegroup"),
             ],
             entry_point = Label("//@bazel/typescript/internal/worker:index.js"),
             templated_args = [
diff --git a/node_modules/@bazel/typescript/internal/worker/index.js b/node_modules/@bazel/typescript/internal/worker/index.js
index 08bf866..2cc5865 100755
--- a/node_modules/@bazel/typescript/internal/worker/index.js
+++ b/node_modules/@bazel/typescript/internal/worker/index.js
@@ -10,10 +10,12 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 const fs = require("fs");
+const path = require("path");
 const ts = require("typescript");
 const MNEMONIC = 'TsProject';
 const worker = require('./worker');
 let createWatchCompilerHost;
+const filesCache = new Map();
 const formatHost = {
     getCanonicalFileName: (path) => path,
     getCurrentDirectory: ts.sys.getCurrentDirectory,
@@ -26,7 +28,15 @@ const reportWatchStatusChanged = (diagnostic) => {
     worker.debug(ts.formatDiagnostic(diagnostic, formatHost));
 };
 function createWatchProgram(options, tsconfigPath, setTimeout) {
-    const host = createWatchCompilerHost(tsconfigPath, options, Object.assign(Object.assign({}, ts.sys), { setTimeout }), ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic, reportWatchStatusChanged);
+    const host = createWatchCompilerHost(tsconfigPath, options, Object.assign(Object.assign({}, ts.sys), { setTimeout, write: worker.debug,
+        writeFile: (filename, ...args) => {
+            ts.sys.writeFile(filename, ...args);
+            // here we collect all output from Typescript into FS to the memory cache
+            // we need it to restore correct FS state between Bazel runs.
+            worker.debug('update files cache with: ', filename);
+            filesCache.set(filename, args);
+        }
+    }), ts.createEmitAndSemanticDiagnosticsBuilderProgram, reportDiagnostic, reportWatchStatusChanged);
     return ts.createWatchProgram(host);
 }
 let workerRequestTimestamp;
@@ -53,10 +63,19 @@ function getWatchProgram(args) {
 function emitOnce(args) {
     return __awaiter(this, void 0, void 0, function* () {
         const watchProgram = getWatchProgram(args);
+        workerRequestTimestamp = Date.now();
         if (consolidateChangesCallback) {
+            // consolidateChangesCallback is defined only when the build triggers a "warm" worker.
+            // In "warm" state TypeScript will emit only changed files,
+            // and, since Bazel clean package output folder for each build,
+            // we need to restore the File System state to what TypeScript expects to see.
+            // To do it we take all files that we previously cache in the filesCache
+            // and rewrite them using TS API.
+            // TODO: it may be more efficient to do the same thing by passing custom ts.CreateProgram factory in the createWatchProgram.
+            filesCache.forEach((args, filename) =>  ts.sys.writeFile(filename, ...args));
+            worker.debug('file restore finished in: ', Date.now() - workerRequestTimestamp, 'ms');
             consolidateChangesCallback();
         }
-        workerRequestTimestamp = Date.now();
         const result = yield (watchProgram === null || watchProgram === void 0 ? void 0 : watchProgram.getProgram().emit(undefined, undefined, {
             isCancellationRequested: function (timestamp) {
                 return timestamp !== workerRequestTimestamp;
@@ -82,6 +101,19 @@ function main() {
     }
     if (process.argv.includes('--persistent_worker')) {
         worker.log(`Running ${MNEMONIC} as a Bazel worker`);
+        // Here we create a symlink to the node_module folder
+        // in a place which Bazel does not clean before each run - output_base.
+        // We can not use the workspace folder for it, because Bazel completely cleans it before each build.
+        // And even if we restore symlink manually, TS watch mode detect it as changes in all node_modules
+        // and will reresolve and recompile all of them which creates significant overhead in build time.
+        var target = path.join(process.cwd(), '../../external/npm/node_modules');
+        var into = path.join(process.cwd(), '../../node_modules');
+        worker.log('link node_modules from', target, 'to', into);
+        try {
+          fs.symlinkSync(target, into, 'junction');
+        } catch (e) {
+          worker.log('link creation failed', e.toString());
+        }
         worker.runWorkerLoop(emitOnce);
     }
     else {
diff --git a/node_modules/@bazel/typescript/internal/worker/worker.js b/node_modules/@bazel/typescript/internal/worker/worker.js
index d6e188a..97d1da7 100755
--- a/node_modules/@bazel/typescript/internal/worker/worker.js
+++ b/node_modules/@bazel/typescript/internal/worker/worker.js
@@ -32,7 +32,8 @@ if (typeof global.gc !== 'function') {
  * Whether to print debug messages (to console.error) from the debug function
  * below.
  */
-exports.DEBUG = false;
+// expose debug logs only for builds with --define=VERBOSE_LOGS=1
+exports.DEBUG = process.env.VERBOSE_LOGS === '1';
 /** Maybe print a debug message (depending on a flag defaulting to false). */
 function debug(...args) {
     if (exports.DEBUG)
